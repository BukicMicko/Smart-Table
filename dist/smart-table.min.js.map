{"version":3,"sources":["smart-table.min.js"],"names":["ng","undefined","module","run","$templateCache","put","constant","pagination","template","itemsByPage","displayedPages","search","delay","inputEvent","trimSearch","select","mode","selectedClass","sort","ascentClass","descentClass","descendingFirst","skipNatural","pipe","controller","$scope","$parse","$filter","$attrs","safeGetter","filtered","lastSelected","propertyName","stTable","displayGetter","displaySetter","assign","orderBy","filter","safeCopy","copyRefs","tableState","start","totalItemCount","pipeAfterSafeCopy","ctrl","this","src","concat","updateSafeCopy","stSafeSrc","$watch","safeSrc","length","newValue","oldValue","sortBy","predicate","reverse","isFunction","functionName","name","input","comparator","predicateObject","prop","predicateTest","angular","isString","distinct","_","has","deepDelete","object","path","indexOf","partials","split","key","pop","parentPath","join","parentObject","Object","keys","output","number","numberOfPages","Math","ceil","slice","parseInt","row","rows","index","isSelected","getFilteredCollection","setFilterFunction","filterName","setSortFunction","sortFunctionName","preventPipeOnWatch","directive","restrict","link","scope","element","attr","stSetFilter","stSetSort","stConfig","$timeout","require","tableCtrl","promise","throttle","stDelay","event","stInputEvent","$observe","value","trim","predicateExpression","stSearch","bind","evt","originalEvent","cancel","target","stSelectMode","$apply","addClass","removeClass","sortDefault","stSort","getter","classAscent","stClassAscent","classDescent","stClassDescent","stateClasses","stSkipNatural","stDescendingFirst","ariaSort","func","isArray","stSortDefault","$eval","stItemsByPage","stDisplayedPages","stPageChange","templateUrl","attrs","stTemplate","redraw","end","i","paginationState","prevPage","currentPage","floor","max","abs","pages","numPages","push","newPage","selectPage","page","config","stPipe","pre","pipePromise","post"],"mappings":"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","file":"smart-table.min.js","sourcesContent":["(function (ng, undefined){\r\n    'use strict';\r\n\nng.module('smart-table', []).run(['$templateCache', function ($templateCache) {\r\n    $templateCache.put('template/smart-table/pagination.html',\r\n        '<nav ng-if=\"numPages && pages.length >= 2\"><ul class=\"pagination\">' +\r\n        '<li ng-repeat=\"page in pages\" ng-class=\"{active: page==currentPage}\"><a href=\"#\" ng-click=\"selectPage(page); $event.preventDefault(); $event.stopPropagation();\">{{page}}</a></li>' +\r\n        '</ul></nav>');\r\n}]);\r\n\r\n\nng.module('smart-table')\r\n  .constant('stConfig', {\r\n    pagination: {\r\n      template: 'template/smart-table/pagination.html',\r\n      itemsByPage: 10,\r\n      displayedPages: 5\r\n    },\r\n    search: {\r\n      delay: 400, // ms\r\n      inputEvent: 'input',\r\n      trimSearch: false\r\n    },\r\n    select: {\r\n      mode: 'single',\r\n      selectedClass: 'st-selected'\r\n    },\r\n    sort: {\r\n      ascentClass: 'st-sort-ascent',\r\n      descentClass: 'st-sort-descent',\r\n      descendingFirst: false,\r\n      skipNatural: false,\r\n      delay:300\r\n    },\r\n    pipe: {\r\n      delay: 100 //ms\r\n    }\r\n  });\nng.module('smart-table').controller('stTableController', [\r\n  '$scope',\r\n  '$parse',\r\n  '$filter',\r\n  '$attrs',\r\n  function StTableController($scope, $parse, $filter, $attrs) {\r\n    var propertyName = $attrs.stTable;\r\n    var displayGetter = $parse(propertyName);\r\n    var displaySetter = displayGetter.assign;\r\n    var safeGetter;\r\n    var orderBy = $filter('orderBy');\r\n    var filter = $filter('filter');\r\n    var safeCopy = copyRefs(displayGetter($scope));\r\n    var tableState = {\r\n      sort: {},\r\n      search: {},\r\n      pagination: { start: 0, totalItemCount: 0 }\r\n    };\r\n    var filtered;\r\n    var pipeAfterSafeCopy = true;\r\n    var ctrl = this;\r\n    var lastSelected;\r\n\r\n    function copyRefs(src) {\r\n      return src ? [].concat(src) : [];\r\n    }\r\n\r\n    function updateSafeCopy() {\r\n      safeCopy = copyRefs(safeGetter($scope));\r\n      if (pipeAfterSafeCopy === true) {\r\n        ctrl.pipe();\r\n      }\r\n    }\r\n\r\n    function deepDelete(object, path) {\r\n      if (path.indexOf('.') != -1) {\r\n        var partials = path.split('.');\r\n        var key = partials.pop();\r\n        var parentPath = partials.join('.');\r\n        var parentObject = $parse(parentPath)(object);\r\n        delete parentObject[key];\r\n        if (Object.keys(parentObject).length == 0) {\r\n          deepDelete(object, parentPath);\r\n        }\r\n      } else {\r\n        delete object[path];\r\n      }\r\n    }\r\n\r\n    if ($attrs.stSafeSrc) {\r\n      safeGetter = $parse($attrs.stSafeSrc);\r\n      $scope.$watch(\r\n        function() {\r\n          var safeSrc = safeGetter($scope);\r\n          return safeSrc && safeSrc.length ? safeSrc[0] : undefined;\r\n        },\r\n        function(newValue, oldValue) {\r\n          if (newValue !== oldValue) {\r\n            updateSafeCopy();\r\n          }\r\n        }\r\n      );\r\n      $scope.$watch(\r\n        function() {\r\n          var safeSrc = safeGetter($scope);\r\n          return safeSrc ? safeSrc.length : 0;\r\n        },\r\n        function(newValue, oldValue) {\r\n          if (newValue !== safeCopy.length) {\r\n            updateSafeCopy();\r\n          }\r\n        }\r\n      );\r\n      $scope.$watch(\r\n        function() {\r\n          return safeGetter($scope);\r\n        },\r\n        function(newValue, oldValue) {\r\n          if (newValue !== oldValue) {\r\n            tableState.pagination.start = 0;\r\n            updateSafeCopy();\r\n          }\r\n        }\r\n      );\r\n    }\r\n\r\n    /**\r\n     * sort the rows\r\n     * @param {Function | String} predicate - function or string which will be used as predicate for the sorting\r\n     * @param [reverse] - if you want to reverse the order\r\n     */\r\n    this.sortBy = function sortBy(predicate, reverse) {\r\n      tableState.sort.predicate = predicate;\r\n      tableState.sort.reverse = reverse === true;\r\n\r\n      if (ng.isFunction(predicate)) {\r\n        tableState.sort.functionName = predicate.name;\r\n      } else {\r\n        delete tableState.sort.functionName;\r\n      }\r\n\r\n      tableState.pagination.start = 0;\r\n      return this.pipe();\r\n    };\r\n\r\n    /**\r\n     * search matching rows\r\n     * @param {String} input - the input string\r\n     * @param {String} [predicate] - the property name against you want to check the match, otherwise it will search on all properties\r\n     * @param {String | Function } [comparator] - a comparator to pass to the filter for the (pass true for stric mode)\r\n     */\r\n    this.search = function search(input, predicate, comparator) {\r\n      var predicateObject = tableState.search.predicateObject || {};\r\n      var prop = predicate ? predicate : '$';\r\n\r\n\t  if (input) {\r\n\t\tvar predicateTest = predicate;\r\n\t\tif (!angular.isString(input)) {\r\n\t\t\tif (input.distinct) {\r\n\t\t\t\tpredicateTest = predicateTest + '.distinct' + input.distinct;\r\n\t\t\t} else {\r\n\t\t\t\tpredicateTest = predicateTest + '.distinct';\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tpredicateTest = predicateTest + '.' + input;\r\n\t\t}\r\n\t\tif (!_.has(predicateObject, predicateTest)) {\r\n\t\t\ttableState.pagination.start = 0;\r\n\t\t}\r\n\t  } \r\n\r\n      $parse(prop).assign(predicateObject, input);\r\n      // to avoid to filter out null value\r\n      if (!input) {\r\n        deepDelete(predicateObject, prop);\r\n      }\r\n      tableState.search.predicateObject = predicateObject;\r\n      return this.pipe();\r\n    };\r\n\r\n    /**\r\n     * this will chain the operations of sorting and filtering based on the current table state (sort options, filtering, ect)\r\n     */\r\n    this.pipe = function pipe() {\r\n      var pagination = tableState.pagination;\r\n      var output;\r\n      filtered = tableState.search.predicateObject\r\n        ? filter(safeCopy, tableState.search.predicateObject)\r\n        : safeCopy;\r\n      if (tableState.sort.predicate) {\r\n        filtered = orderBy(\r\n          filtered,\r\n          tableState.sort.predicate,\r\n          tableState.sort.reverse\r\n        );\r\n      }\r\n      pagination.totalItemCount = filtered.length;\r\n      if (pagination.number !== undefined) {\r\n        pagination.numberOfPages = filtered.length > 0\r\n          ? Math.ceil(filtered.length / pagination.number)\r\n          : 1;\r\n        pagination.start = pagination.start >= filtered.length\r\n          ? (pagination.numberOfPages - 1) * pagination.number\r\n          : pagination.start;\r\n        output = filtered.slice(\r\n          pagination.start,\r\n          pagination.start + parseInt(pagination.number)\r\n        );\r\n      }\r\n      displaySetter($scope, output || filtered);\r\n    };\r\n\r\n    /**\r\n     * select a dataRow (it will add the attribute isSelected to the row object)\r\n     * @param {Object} row - the row to select\r\n     * @param {String} [mode] - \"single\" or \"multiple\" (multiple by default)\r\n     */\r\n    this.select = function select(row, mode) {\r\n      var rows = copyRefs(displayGetter($scope));\r\n      var index = rows.indexOf(row);\r\n      if (index !== -1) {\r\n        if (mode === 'single') {\r\n          row.isSelected = row.isSelected !== true;\r\n          if (lastSelected) {\r\n            lastSelected.isSelected = false;\r\n          }\r\n          lastSelected = row.isSelected === true ? row : undefined;\r\n        } else {\r\n          rows[index].isSelected = !rows[index].isSelected;\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * take a slice of the current sorted/filtered collection (pagination)\r\n     *\r\n     * @param {Number} start - start index of the slice\r\n     * @param {Number} number - the number of item in the slice\r\n     */\r\n    this.slice = function splice(start, number) {\r\n      tableState.pagination.start = start;\r\n      tableState.pagination.number = number;\r\n      return this.pipe();\r\n    };\r\n\r\n    /**\r\n     * return the current state of the table\r\n     * @returns {{sort: {}, search: {}, pagination: {start: number}}}\r\n     */\r\n    this.tableState = function getTableState() {\r\n      return tableState;\r\n    };\r\n\r\n    this.getFilteredCollection = function getFilteredCollection() {\r\n      return filtered || safeCopy;\r\n    };\r\n\r\n    /**\r\n     * Use a different filter function than the angular FilterFilter\r\n     * @param filterName the name under which the custom filter is registered\r\n     */\r\n    this.setFilterFunction = function setFilterFunction(filterName) {\r\n      filter = $filter(filterName);\r\n    };\r\n\r\n    /**\r\n     * Use a different function than the angular orderBy\r\n     * @param sortFunctionName the name under which the custom order function is registered\r\n     */\r\n    this.setSortFunction = function setSortFunction(sortFunctionName) {\r\n      orderBy = $filter(sortFunctionName);\r\n    };\r\n\r\n    /**\r\n     * Usually when the safe copy is updated the pipe function is called.\r\n     * Calling this method will prevent it, which is something required when using a custom pipe function\r\n     */\r\n    this.preventPipeOnWatch = function preventPipe() {\r\n      pipeAfterSafeCopy = false;\r\n    };\r\n  }\r\n]).directive('stTable', function() {\r\n  return {\r\n    restrict: 'A',\r\n    controller: 'stTableController',\r\n    link: function(scope, element, attr, ctrl) {\r\n      if (attr.stSetFilter) {\r\n        ctrl.setFilterFunction(attr.stSetFilter);\r\n      }\r\n\r\n      if (attr.stSetSort) {\r\n        ctrl.setSortFunction(attr.stSetSort);\r\n      }\r\n    }\r\n  };\r\n});\r\n\nng.module('smart-table')\r\n  .directive('stSearch', ['stConfig', '$timeout','$parse', function (stConfig, $timeout, $parse) {\r\n    return {\r\n      require: '^stTable',\r\n      link: function (scope, element, attr, ctrl) {\r\n        var tableCtrl = ctrl;\r\n        var promise = null;\r\n        var throttle = attr.stDelay || stConfig.search.delay;\r\n        var event = attr.stInputEvent || stConfig.search.inputEvent;\r\n        var trimSearch = attr.trimSearch || stConfig.search.trimSearch;\r\n\r\n        attr.$observe('stSearch', function (newValue, oldValue) {\r\n          var input = element[0].value;\r\n          if (newValue !== oldValue && input) {\r\n            ctrl.tableState().search = {};\r\n            input = ng.isString(input) && trimSearch ? input.trim() : input;\r\n            tableCtrl.search(input, newValue);\r\n          }\r\n        });\r\n\r\n        //table state -> view\r\n        scope.$watch(function () {\r\n          return ctrl.tableState().search;\r\n        }, function (newValue, oldValue) {\r\n          var predicateExpression = attr.stSearch || '$';\r\n          if (newValue.predicateObject && $parse(predicateExpression)(newValue.predicateObject) !== element[0].value) {\r\n            element[0].value = $parse(predicateExpression)(newValue.predicateObject) || '';\r\n          }\r\n        }, true);\r\n\r\n        // view -> table state\r\n        element.bind(event, function (evt) {\r\n          evt = evt.originalEvent || evt;\r\n          if (promise !== null) {\r\n            $timeout.cancel(promise);\r\n          }\r\n\r\n          promise = $timeout(function () {\r\n            var input = evt.target.value;\r\n            input = ng.isString(input) && trimSearch ? input.trim() : input;\r\n            tableCtrl.search(input, attr.stSearch || '');\r\n            promise = null;\r\n          }, throttle);\r\n        });\r\n      }\r\n    };\r\n  }]);\r\n\nng.module('smart-table')\r\n  .directive('stSelectRow', ['stConfig', function (stConfig) {\r\n    return {\r\n      restrict: 'A',\r\n      require: '^stTable',\r\n      scope: {\r\n        row: '=stSelectRow'\r\n      },\r\n      link: function (scope, element, attr, ctrl) {\r\n        var mode = attr.stSelectMode || stConfig.select.mode;\r\n        element.bind('click', function () {\r\n          scope.$apply(function () {\r\n            ctrl.select(scope.row, mode);\r\n          });\r\n        });\r\n\r\n        scope.$watch('row.isSelected', function (newValue) {\r\n          if (newValue === true) {\r\n            element.addClass(stConfig.select.selectedClass);\r\n          } else {\r\n            element.removeClass(stConfig.select.selectedClass);\r\n          }\r\n        });\r\n      }\r\n    };\r\n  }]);\r\n\nng.module('smart-table')\r\n  .directive('stSort', ['stConfig', '$parse', '$timeout', function (stConfig, $parse, $timeout) {\r\n    return {\r\n      restrict: 'A',\r\n      require: '^stTable',\r\n      link: function (scope, element, attr, ctrl) {\r\n\r\n        var predicate = attr.stSort;\r\n        var getter = $parse(predicate);\r\n        var index = 0;\r\n        var classAscent = attr.stClassAscent || stConfig.sort.ascentClass;\r\n        var classDescent = attr.stClassDescent || stConfig.sort.descentClass;\r\n        var stateClasses = [classAscent, classDescent];\r\n        var sortDefault;\r\n        var skipNatural = attr.stSkipNatural !== undefined ? attr.stSkipNatural : stConfig.sort.skipNatural;\r\n        var descendingFirst = attr.stDescendingFirst !== undefined ? attr.stDescendingFirst : stConfig.sort.descendingFirst;\r\n        var promise = null;\r\n        var throttle = attr.stDelay || stConfig.sort.delay;\r\n\r\n        // set aria attributes\r\n        var ariaSort = 'aria-sort';\r\n        var ariaSortNone = 'none';\r\n        var ariaSortAscending = 'ascending';\r\n        var ariaSortDescending = 'descending';\r\n        element\r\n          .attr('role', 'columnheader')\r\n          .attr(ariaSort, ariaSortNone);\r\n\r\n        if (attr.stSortDefault) {\r\n          sortDefault = scope.$eval(attr.stSortDefault) !== undefined ? scope.$eval(attr.stSortDefault) : attr.stSortDefault;\r\n        }\r\n\r\n        //view --> table state\r\n        function sort () {\r\n          if (descendingFirst) {\r\n            index = index === 0 ? 2 : index - 1;\r\n          } else {\r\n            index++;\r\n          }\r\n\r\n          var func;\r\n          predicate = ng.isFunction(getter(scope)) || ng.isArray(getter(scope)) ? getter(scope) : attr.stSort;\r\n          if (index % 3 === 0 && !!skipNatural !== true) {\r\n            //manual reset\r\n            index = 0;\r\n            ctrl.tableState().sort = {};\r\n            ctrl.tableState().pagination.start = 0;\r\n            func = ctrl.pipe.bind(ctrl);\r\n          } else {\r\n            func = ctrl.sortBy.bind(ctrl, predicate, index % 2 === 0);\r\n          }\r\n          if (promise !== null) {\r\n            $timeout.cancel(promise);\r\n          }\r\n          if (throttle < 0) {\r\n            func();\r\n          } else {\r\n            promise = $timeout(function(){\r\n              func();\r\n            }, throttle);\r\n          }\r\n        }\r\n\r\n        element.bind('click', function sortClick () {\r\n          if (predicate) {\r\n            scope.$apply(sort);\r\n          }\r\n        });\r\n\r\n        if (sortDefault) {\r\n          index = sortDefault === 'reverse' ? 1 : 0;\r\n          sort();\r\n        }\r\n\r\n        //table state --> view\r\n        scope.$watch(function () {\r\n          return ctrl.tableState().sort;\r\n        }, function (newValue) {\r\n          if (newValue.predicate !== predicate) {\r\n            index = 0;\r\n            element\r\n              .removeClass(classAscent)\r\n              .removeClass(classDescent)\r\n              .attr(ariaSort, ariaSortNone);\r\n          } else {\r\n            index = newValue.reverse === true ? 2 : 1;\r\n            element\r\n              .removeClass(stateClasses[index % 2])\r\n              .addClass(stateClasses[index - 1])\r\n              .attr(ariaSort, newValue.reverse ? ariaSortAscending : ariaSortDescending);\r\n          }\r\n        }, true);\r\n      }\r\n    };\r\n  }]);\r\n\nng.module('smart-table')\r\n  .directive('stPagination', ['stConfig', function (stConfig) {\r\n    return {\r\n      restrict: 'EA',\r\n      require: '^stTable',\r\n      scope: {\r\n        stItemsByPage: '=?',\r\n        stDisplayedPages: '=?',\r\n        stPageChange: '&'\r\n      },\r\n      templateUrl: function (element, attrs) {\r\n        if (attrs.stTemplate) {\r\n          return attrs.stTemplate;\r\n        }\r\n        return stConfig.pagination.template;\r\n      },\r\n      link: function (scope, element, attrs, ctrl) {\r\n\r\n        scope.stItemsByPage = scope.stItemsByPage ? +(scope.stItemsByPage) : stConfig.pagination.itemsByPage;\r\n        scope.stDisplayedPages = scope.stDisplayedPages ? +(scope.stDisplayedPages) : stConfig.pagination.displayedPages;\r\n\r\n        scope.currentPage = 1;\r\n        scope.pages = [];\r\n\r\n        function redraw () {\r\n          var paginationState = ctrl.tableState().pagination;\r\n          var start = 1;\r\n          var end;\r\n          var i;\r\n          var prevPage = scope.currentPage;\r\n          scope.totalItemCount = paginationState.totalItemCount;\r\n          scope.currentPage = Math.floor(paginationState.start / paginationState.number) + 1;\r\n\r\n          start = Math.max(start, scope.currentPage - Math.abs(Math.floor(scope.stDisplayedPages / 2)));\r\n          end = start + scope.stDisplayedPages;\r\n\r\n          if (end > paginationState.numberOfPages) {\r\n            end = paginationState.numberOfPages + 1;\r\n            start = Math.max(1, end - scope.stDisplayedPages);\r\n          }\r\n\r\n          scope.pages = [];\r\n          scope.numPages = paginationState.numberOfPages;\r\n\r\n          for (i = start; i < end; i++) {\r\n            scope.pages.push(i);\r\n          }\r\n\r\n          if (prevPage !== scope.currentPage) {\r\n            scope.stPageChange({newPage: scope.currentPage});\r\n          }\r\n        }\r\n\r\n        //table state --> view\r\n        scope.$watch(function () {\r\n          return ctrl.tableState().pagination;\r\n        }, redraw, true);\r\n\r\n        //scope --> table state  (--> view)\r\n        scope.$watch('stItemsByPage', function (newValue, oldValue) {\r\n          if (newValue !== oldValue) {\r\n            scope.selectPage(1);\r\n          }\r\n        });\r\n\r\n        scope.$watch('stDisplayedPages', redraw);\r\n\r\n        //view -> table state\r\n        scope.selectPage = function (page) {\r\n          if (page > 0 && page <= scope.numPages) {\r\n            ctrl.slice((page - 1) * scope.stItemsByPage, scope.stItemsByPage);\r\n          }\r\n        };\r\n\r\n        if (!ctrl.tableState().pagination.number) {\r\n          ctrl.slice(0, scope.stItemsByPage);\r\n        }\r\n      }\r\n    };\r\n  }]);\r\n\nng.module('smart-table')\r\n  .directive('stPipe', ['stConfig', '$timeout', function (config, $timeout) {\r\n    return {\r\n      require: 'stTable',\r\n      scope: {\r\n        stPipe: '='\r\n      },\r\n      link: {\r\n\r\n        pre: function (scope, element, attrs, ctrl) {\r\n\r\n          var pipePromise = null;\r\n\r\n          if (ng.isFunction(scope.stPipe)) {\r\n            ctrl.preventPipeOnWatch();\r\n            ctrl.pipe = function () {\r\n\r\n              if (pipePromise !== null) {\r\n                $timeout.cancel(pipePromise)\r\n              }\r\n\r\n              pipePromise = $timeout(function () {\r\n                scope.stPipe(ctrl.tableState(), ctrl);\r\n              }, config.pipe.delay);\r\n\r\n              return pipePromise;\r\n            }\r\n          }\r\n        },\r\n\r\n        post: function (scope, element, attrs, ctrl) {\r\n          ctrl.pipe();\r\n        }\r\n      }\r\n    };\r\n  }]);\r\n\n})(angular);"]}